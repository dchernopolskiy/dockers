<?xml version='1.0' standalone='yes'?>

<!DOCTYPE PLUGIN [
<!ENTITY name      "dockerMan">
<!ENTITY author    "gfjardim">
<!ENTITY version   "2014.08.03">
<!ENTITY category  "Core Functionality">
<!ENTITY pluginURL "https://raw.githubusercontent.com/gfjardim/dockers/dockerMan/dockerMan/dockerMan.plg">
]>

<PLUGIN  name="&name;"
         author="&author;"
         version="&version;"
         category="&category;"
         pluginURL="&pluginURL;">
<!--
get from github as tarball
-->
<FILE Name="/boot/config/plugins/&name;/&name;-&version;.tar.gz">
<URL>"https://github.com/gfjardim/dockers/archive/dockerMan.tar.gz"</URL>
</FILE>

<FILE Name="/tmp/docker-cleanup" Run="/bin/bash">
<INLINE>
rm -f /etc/rc.d/rc.docker
rm -f /etc/default/docker
rm -rf /usr/local/emhttp/plugins/&name;
rm -f /usr/local/sbin/DockerUpdate.php
tar -zxf /boot/config/plugins/&name;/&name;-&version;.tar.gz --strip=1 -C /usr/local/emhttp/plugins/
find /boot/config/plugins/&name; -type f ! -iname "&name;-&version;.tar.gz" -delete
rm -f /tmp/docker-cleanup
</INLINE>
</FILE>

<FILE Name="/usr/local/sbin/DockerUpdate.php" Mode="0770">
<INLINE>
<![CDATA[
#!/usr/bin/php
<?
include_once("/usr/local/emhttp/plugins/dockerMan/DockerClient.php");

$DockerUpdate = new DockerUpdate();
if ( $argv[1] == "-d"){
  exec("/usr/local/sbin/DockerUpdate.php > /dev/null 2>&1 &");
} else {
  while ( TRUE ) {
    echo "Reloading status.";
    $DockerUpdate->reloadUpdateStatus();
    sleep(60);
  }
}
?>
]]>
</INLINE>
</FILE>

<FILE Name="/tmp/update-run" Run="/bin/bash">
<INLINE>
<![CDATA[
/usr/local/sbin/DockerUpdate.php -d
rm /tmp/update-run
]]>
</INLINE>
</FILE>

<FILE Name="/etc/rc.d/rc.docker" Mode="0770">
<INLINE>
<![CDATA[
#!/bin/sh

# Short-Description:  Create lightweight, portable, self-sufficient containers.
# Description:
#  Docker is an open-source project to easily create lightweight, portable,
#  self-sufficient containers from any application. The same container that a
#  developer builds and tests on a laptop can run at scale, in production, on
#  VMs, bare metal, OpenStack clusters, public clouds and more.


PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin

BASE=docker

DOCKER=/usr/bin/$BASE
DOCKER_PIDFILE=/var/run/$BASE.pid
DOCKER_LOG=/var/log/docker.log
DOCKER_OPTS=
DOCKER_HOME=
DOCKER_CONTAINERS=

if [ -f /etc/default/$BASE ]; then
	. /etc/default/$BASE
fi

# Check docker is present
if [ ! -x $DOCKER ]; then
	echo "$DOCKER not present or not executable"
	exit 1
fi

while IFS="," read -ra LINES; do
  for LINE in "${LINES[@]}"; do
	MANAGED_CONTAINERS+="$LINE"$'\n'
  done
done <<< "$DOCKER_CONTAINERS"


# Verify if docker daemon running
is_docker_running(){
  if [[ $(docker ps 2>&1) =~ "CONTAINER ID" ]]; then return 0; else return 1; fi
}

# Wait 10s to daemon start
wait_daemon(){
  for n in $(seq 10); do
    if is_docker_running; then return 0; else sleep 1; fi
  done
  return 1
}

# Containers Management
# All existing containers
all_containers(){
  while IFS=$'\n' read -ra LINES; do
    for LINE in "${LINES[@]}"; do
      IFS="  " read -ra VALUES <<< "$LINES"
      echo -e "${VALUES[@]:(-1)}\n"
    done
  done <<< "$(docker ps -a 2>/dev/null | grep -v CONTAINER)"
}

# Running containers
running_containers(){
  while IFS=$'\n' read -ra LINES; do
    for LINE in "${LINES[@]}"; do
      IFS="  " read -ra VALUES <<< "$LINES"
      echo -e "${VALUES[@]:(-1)}\n"
    done
  done <<< "$(docker ps 2>/dev/null | grep -v CONTAINER)"
}

# Is container running?
is_container_running(){
  local CONTAINER
  for CONTAINER in $(running_containers); do
    if [[ $CONTAINER == $1 ]]; then
      return 0
    fi
  done
  return 1
}

# Does the container exist?
container_exist(){
  local CONTAINER
  for CONTAINER in $(all_containers); do
    if [[ $CONTAINER == $1 ]]; then
      return 0
    fi
  done
  return 1
}

# Start containers
start_containers(){
  local CONTAINER
  CMD="docker start"
  wait_daemon
  if ! is_docker_running; then return 1; fi
  for CONTAINER in $MANAGED_CONTAINERS; do
    if container_exist $CONTAINER && ! is_container_running $CONTAINER; then 
      OUT=$(eval "$CMD $CONTAINER" 2>&1)
      if  [[ $OUT =~ "Error:" ]]; then
        echo -n $CONTAINER": "$OUT
      else
        echo "$CONTAINER: started succesfully!"
      fi
    fi
  done
}

docker_start() {
  if is_docker_running; then
    echo "docker already running"
    return 1
  fi
  
  if [ -z "$DOCKER_HOME" ]; then
    echo "ERROR: Docker install path is empty"
    exit 1
  fi

  # Make sure path sits off a btrfs device
  IS_BTRFS=0
  TMP="$DOCKER_HOME"
  while [ "$TMP" != "$(dirname "$TMP")" ]; do
    if [ ! -z "$(df -T "$TMP" -t btrfs 2>/dev/null | grep 'btrfs')" ]; then
      IS_BTRFS=1
      break
    fi
    TMP=$(dirname "$TMP")
  done

  if [ $IS_BTRFS -eq 0 ]; then
    echo "ERROR: Docker install path ($DOCKER_HOME) must be off a btrfs device"
    exit 1
  fi

  if [ ! -d "$DOCKER_HOME" ]; then
    mkdir -p "$DOCKER_HOME"
  fi

  echo "starting $BASE ..."
  if [ -x ${DOCKER} ]; then
    # If there is an old PID file (no docker running), clean it up:
    if [ -r ${DOCKER_PIDFILE} ]; then
      if ! ps axc | grep docker 1> /dev/null 2> /dev/null ; then
        echo "Cleaning up old ${DOCKER_PIDFILE}."
        rm -f ${DOCKER_PIDFILE}
      fi
    fi
    nohup ${DOCKER} -d -p ${DOCKER_PIDFILE} ${DOCKER_OPTS} >> ${DOCKER_LOG} 2>&1 &
  fi
}

# Stop docker:
docker_stop() {
  echo "stopping $BASE ..."
  # If there is no PID file, ignore this request...
  if [ -r ${DOCKER_PIDFILE} ]; then
    RUNNING=$(docker ps -q)
    if [[ $RUNNING ]]; then
      docker stop $RUNNING
    fi
    kill $(cat ${DOCKER_PIDFILE})
  fi
}

# Restart docker:
docker_restart() {
	docker_stop
	sleep 1
	docker_start
	start_containers
}

case "$1" in
'start')
  docker_start
  start_containers
  ;;
'stop')
  docker_stop
  ;;
'restart')
  docker_restart
  ;;
'status')
  if [ -f ${DOCKER_PIDFILE} ] && ps -o cmd $(cat ${DOCKER_PIDFILE}) | grep -q $BASE ; then
	  echo "status of $BASE: running"
	  echo "running containers:" $(running_containers)
  else
	  echo "status of $BASE: stopped"
  fi
  ;;
*)
  echo "usage $0 start|stop|restart|status"
esac

exit 0
]]>
</INLINE>
</FILE>

<FILE Name="/etc/default/docker">
<INLINE>
<![CDATA[
## Set defaults used by the docker daemon
## These are flags passed after `docker -d`
DOCKER_OPTS="--storage-driver=btrfs"
DOCKER_HOME="/mnt/cache/docker"

if [ -f /boot/config/docker.cfg ]; then
  . /boot/config/docker.cfg
else
  echo "# Generated settings:" >> /boot/config/docker.cfg
  echo "DOCKER_HOME=\"$DOCKER_HOME\"" >> /boot/config/docker.cfg
  echo "DOCKER_OPTS=\"$DOCKER_OPTS\"" >> /boot/config/docker.cfg
  echo "DOCKER_CONTAINERS=\"\"" >> /boot/config/docker.cfg
fi

DOCKER_OPTS="--graph=$DOCKER_HOME $DOCKER_OPTS"

if grep -wq unraidsafemode /proc/cmdline ; then
  DOCKER_OPTS="--restart=false $DOCKER_OPTS"
fi

export DOCKER_RAMDISK=true
]]>
</INLINE>
</FILE>

</PLUGIN>
